RESUMO PARA DEFESA DE CÃ“DIGO
Tema: Sistema de Gerenciamento de Eventos
ExercÃ­cios atendidos: 4 (Classe Abstrata), 5 (Polimorfismo de Sobrescrita), 6 (Polimorfismo de Sobrecarga), 13 (Clean Code)

âœ… ExercÃ­cio 4 â€” Classe Abstrata
âœ”ï¸ O que foi feito:
Criei a classe abstrata Usuario com os atributos comuns: nome e email.

IncluÃ­ um mÃ©todo abstrato chamado exibirDados(), que obriga todas as subclasses a implementarem seu prÃ³prio comportamento.

ğŸ¤ Como explicar:
A classe Usuario Ã© abstrata porque ela nÃ£o representa um usuÃ¡rio real diretamente, mas sim um conceito geral.
Com isso, eu garanto que todas as subclasses (como Organizador e Participante) terÃ£o o mÃ©todo exibirDados() com sua prÃ³pria lÃ³gica. Isso aumenta a flexibilidade e reaproveitamento do cÃ³digo.

âœ… ExercÃ­cio 5 â€” Polimorfismo de Sobrescrita
âœ”ï¸ O que foi feito:
Nas classes Organizador e Participante, redefini o mÃ©todo exibirDados() para que cada um apresente as informaÃ§Ãµes do seu jeito.

ğŸ¤ Como explicar:
O mÃ©todo exibirDados() Ã© um exemplo de polimorfismo por sobrescrita, porque o mesmo mÃ©todo Ã© implementado de forma diferente em cada subclasse.
Assim, quando eu chamo esse mÃ©todo, o sistema sabe qual versÃ£o deve ser executada com base no tipo de objeto.
Isso melhora a organizaÃ§Ã£o e permite que cada tipo de usuÃ¡rio se comporte conforme suas necessidades.

âœ… ExercÃ­cio 6 â€” Polimorfismo de Sobrecarga
âœ”ï¸ O que foi feito:
Criei a classe Relatorio com trÃªs mÃ©todos gerar(), cada um com parÃ¢metros diferentes:

Um sem nenhum parÃ¢metro.

Um com o parÃ¢metro tipoEvento.

Um com tipoEvento e ano.

ğŸ¤ Como explicar:
Aqui temos o polimorfismo por sobrecarga, onde mÃ©todos com o mesmo nome (gerar) tÃªm comportamentos diferentes dependendo da quantidade e tipo de parÃ¢metros.
Isso facilita o uso do mÃ©todo e evita criar nomes diferentes para funÃ§Ãµes que tÃªm o mesmo propÃ³sito, mantendo o cÃ³digo mais limpo e intuitivo.

âœ… ExercÃ­cio 13 â€” Clean Code
âœ”ï¸ O que foi feito:
Usei nomes claros e descritivos para classes, variÃ¡veis e mÃ©todos.

Separei as responsabilidades em arquivos diferentes (padrÃ£o MVC).

Mantive os mÃ©todos curtos e objetivos.

Usei indentaÃ§Ã£o correta e lÃ³gica clara.

Apliquei encapsulamento com getters e setters.

ğŸ¤ Como explicar:
Em todo o projeto eu apliquei os princÃ­pios de Clean Code, que servem para deixar o cÃ³digo limpo, legÃ­vel e fÃ¡cil de manter.
Usei nomes que indicam exatamente o que o cÃ³digo faz, evitei repetiÃ§Ãµes, e dividi o sistema em camadas (modelo, controlador, visual).
Assim, qualquer pessoa que leia meu cÃ³digo vai entender facilmente sua lÃ³gica e poderÃ¡ trabalhar junto ou fazer melhorias sem dificuldades.

ğŸ“Œ Extras que vocÃª pode comentar:
O projeto segue orientaÃ§Ã£o a objetos, com heranÃ§a, abstraÃ§Ã£o, encapsulamento e polimorfismo.

A estrutura modular ajuda a crescer o sistema futuramente (ex: integrar banco de dados, interface grÃ¡fica, etc).

EstÃ¡ pronto para aplicar serializaÃ§Ã£o e logs com os arquivos Serializador.java e LogUtil.java.

