RESUMO PARA DEFESA DE CÃ“DIGO
Tema: Sistema de Gerenciamento de Eventos
ExercÃ­cios atendidos: 4 (Classe Abstrata), 5 (Polimorfismo de Sobrescrita), 6 (Polimorfismo de Sobrecarga), 13 (Clean Code)

âœ… ExercÃ­cio 4 â€” Classe Abstrata
âœ”ï¸ O que foi feito:
Criei a classe abstrata Usuario com os atributos comuns: nome e email.

IncluÃ­ um mÃ©todo abstrato chamado exibirDados(), que obriga todas as subclasses a implementarem seu prÃ³prio comportamento.

ğŸ¤ Como explicar:
A classe Usuario Ã© abstrata porque ela nÃ£o representa um usuÃ¡rio real diretamente, mas sim um conceito geral.
Com isso, eu garanto que todas as subclasses (como Organizador e Participante) terÃ£o o mÃ©todo exibirDados() com sua prÃ³pria lÃ³gica. Isso aumenta a flexibilidade e reaproveitamento do cÃ³digo.

âœ… ExercÃ­cio 5 â€” Polimorfismo de Sobrescrita
âœ”ï¸ O que foi feito:
Nas classes Organizador e Participante, redefini o mÃ©todo exibirDados() para que cada um apresente as informaÃ§Ãµes do seu jeito.

ğŸ¤ Como explicar:
O mÃ©todo exibirDados() Ã© um exemplo de polimorfismo por sobrescrita, porque o mesmo mÃ©todo Ã© implementado de forma diferente em cada subclasse.
Assim, quando eu chamo esse mÃ©todo, o sistema sabe qual versÃ£o deve ser executada com base no tipo de objeto.
Isso melhora a organizaÃ§Ã£o e permite que cada tipo de usuÃ¡rio se comporte conforme suas necessidades.

âœ… ExercÃ­cio 6 â€” Polimorfismo de Sobrecarga
âœ”ï¸ O que foi feito:
Criei a classe Relatorio com trÃªs mÃ©todos gerar(), cada um com parÃ¢metros diferentes:

Um sem nenhum parÃ¢metro.

Um com o parÃ¢metro tipoEvento.

Um com tipoEvento e ano.

ğŸ¤ Como explicar:
Aqui temos o polimorfismo por sobrecarga, onde mÃ©todos com o mesmo nome (gerar) tÃªm comportamentos diferentes dependendo da quantidade e tipo de parÃ¢metros.
Isso facilita o uso do mÃ©todo e evita criar nomes diferentes para funÃ§Ãµes que tÃªm o mesmo propÃ³sito, mantendo o cÃ³digo mais limpo e intuitivo.

âœ… ExercÃ­cio 13 â€” Clean Code
âœ”ï¸ O que foi feito:
Usei nomes claros e descritivos para classes, variÃ¡veis e mÃ©todos.

Separei as responsabilidades em arquivos diferentes (padrÃ£o MVC).

Mantive os mÃ©todos curtos e objetivos.

Usei indentaÃ§Ã£o correta e lÃ³gica clara.

Apliquei encapsulamento com getters e setters.

ğŸ¤ Como explicar:
Em todo o projeto eu apliquei os princÃ­pios de Clean Code, que servem para deixar o cÃ³digo limpo, legÃ­vel e fÃ¡cil de manter.
Usei nomes que indicam exatamente o que o cÃ³digo faz, evitei repetiÃ§Ãµes, e dividi o sistema em camadas (modelo, controlador, visual).
Assim, qualquer pessoa que leia meu cÃ³digo vai entender facilmente sua lÃ³gica e poderÃ¡ trabalhar junto ou fazer melhorias sem dificuldades.

ğŸ“Œ Extras que vocÃª pode comentar:
O projeto segue orientaÃ§Ã£o a objetos, com heranÃ§a, abstraÃ§Ã£o, encapsulamento e polimorfismo.

A estrutura modular ajuda a crescer o sistema futuramente (ex: integrar banco de dados, interface grÃ¡fica, etc).

EstÃ¡ pronto para aplicar serializaÃ§Ã£o e logs com os arquivos Serializador.java e LogUtil.java.

----------------------------------------------------------------------------------------------------------------------------


ROTEIRO PARA DEFESA INTERLIGADA (ideal para perguntas do professor)
ğŸŸ¢ 1. Comece falando da estrutura geral
â€œO meu projeto Ã© baseado no padrÃ£o MVC, entÃ£o eu separei o cÃ³digo em:

Model: onde ficam as classes principais como Evento, Usuario, Participante, Organizador, Relatorio.

Controller: onde estÃ£o os controles de cadastro.

View: usei o Main.java com menu no console.
Isso me ajuda a organizar melhor a lÃ³gica e a deixar cada parte com uma responsabilidade clara â€” que Ã© um dos princÃ­pios de Clean Code.â€

ğŸ”µ 2. Introduza a classe abstrata (exercÃ­cio 4)
â€œNo model, criei uma classe abstrata chamada Usuario.
Essa classe representa qualquer tipo de usuÃ¡rio do sistema. Ela nÃ£o pode ser instanciada diretamente, e define um mÃ©todo abstrato exibirDados() que deve ser implementado por quem herda.â€

ğŸŸ£ 3. Fale das classes filhas e da sobrescrita (exercÃ­cio 5)
â€œDuas classes herdaram de Usuario: Participante e Organizador.
Cada uma sobrescreve o mÃ©todo exibirDados() do seu jeito.
Isso Ã© polimorfismo de sobrescrita â€” onde o mesmo mÃ©todo se comporta de forma diferente dependendo da classe.
Com isso, posso tratar todos como Usuario, mas o sistema executa o comportamento correto.â€

ğŸŸ  4. Explique o polimorfismo de sobrecarga (exercÃ­cio 6)
â€œNa classe Relatorio, usei polimorfismo de sobrecarga, criando o mÃ©todo gerar() com diferentes versÃµes:

Um sem parÃ¢metros

Um com o tipo do evento

E outro com tipo e ano
Isso permite usar o mesmo nome de mÃ©todo para situaÃ§Ãµes diferentes, tornando o cÃ³digo mais limpo e reutilizÃ¡vel.â€

ğŸŸ¡ 5. Fale sobre Clean Code (exercÃ­cio 13)
â€œDurante todo o projeto, segui os princÃ­pios de Clean Code:

Usei nomes descritivos que explicam o que fazem

Mantive os mÃ©todos pequenos e objetivos

Separei responsabilidades

Apliquei encapsulamento com getters e setters

Evitei repetiÃ§Ãµes e organizei tudo por pacotes
Isso facilita a leitura, a manutenÃ§Ã£o e o trabalho em equipe.â€

ğŸ” 6. Encadeie os assuntos com naturalidade
Se o professor perguntar, por exemplo:

"Por que vocÃª usou uma interface?"
VocÃª pode dizer:

â€œPara padronizar o comportamento das classes de controle. A interface ICadastro obriga todos os controladores a terem os mÃ©todos de CRUD. Isso garante consistÃªncia e tambÃ©m ajuda a aplicar os princÃ­pios de coesÃ£o e Clean Code.â€

ğŸ Conclua com seguranÃ§a:
â€œO cÃ³digo que fiz Ã© simples, mas representa bem os conceitos de orientaÃ§Ã£o a objetos, Clean Code e estrutura organizada.
Mesmo sem interface grÃ¡fica ou banco de dados, o foco foi mostrar meu entendimento prÃ¡tico dos pilares exigidos no projeto.â€

